# 자바 기본 개념 정리
> 가술면접 준비



## 1. 자바를 컴파일하고 실행하는 방법
- 자바에서의 컴파일이란 자바 언어로 된 코드를 JVM이 인식할 수 있는 JVM 명령어 코드(바이트 코드)로 변환하는 것을 의미한다.
드물지만 자바에서의 컴파일도 일반적인 의미의 컴파일처럼 기계가 인식할 수 있는 코드로 변환하는 과정을 의미할 때도 있는데 예를들어 JIT 컴파일러가 하는 컴파일은 바이트코드로 변환하는 것이 아니라 바이트코드를 네이티브 코드로 변환하는 것을 의미한다. 일반적으로 컴파일을 할 때, 전처리, 컴파일, 어셈블리, 링크의 단계를 거치는데  자바는 컴파일의 결과로 나온 바이트 코드가 JVM에 의해 실행되면서 네이티브 기계어로 변환되므로, 프로그램 실행전에 네이티브 기계어 코드를 만들어내는 어셈블리 단계가 없다. 따라서  자바 컴파일의 단계는 `자바 소스 코드 파일(.java) -> javac 컴파일러 -> JVM 바이트코드(.class)`로 나타낼 수 있다. 

- 자바 어플리케이션의 실행은 java 명령어로 수행할 수 있고 다음과 같은 단계로 진행된다. 
> java 명령어는 자바 어플리케이션을 실행한다
> java 명령어는 먼저 JRE(Java Runtime Environment)를 시작하고,
인자로 지정된 클래스(public static void main(String[] args)를 포함하고 있는 클래스)를 로딩하고,
> main() 메서드를 호출한다.

 
##2. 자바의 기본 자료형및 크기

| 분류 | 이름        |바이트수 |비고 |
|------|---------|--------|-----|
|   정수   | byte   |        1     | 	-127 ~ +128      |
|        |  short   |2   |	-32,768 ~ + 32,767             |       |
| |int |4|	-2,147,483,648 ~ +2,147,483,647|
| |long|8|	-9,223,372,036,854,775,808~+9,223,372,036,854,775,807|
| 실수형|float|4|단정도 실수형 (유효 자리는 7 정도임)|
| |double|8|배정도 실수형 (유효 자리는 15정도)|
| 문자형|char|2|유니코드 문자열|
| 논리형|boolean|1|true, false|



- 정수형은 정수를 저장하는 자료형으로서 byte, short, int, long 네 가지가 있으며 각각에 저장할 수 있는 정수의 범위가 다르다 (표  참조) 한 가지 알아둘 것은 C/C++ 과 다르게 자바의 정수형에는 unsigned 형이 없고 부호 있는 정수형만 있다는 것이다. (자료 구조의 단순함을 유지하기 위해서 이렇게 설계했다고 한다.) 그리고 C/C++의 long long int 가 자바의 long형에 해당된다. 숫자 상수끝에 L/l 접미어가 붙으면 long형으로 저장된다.

  실수형은 실수(소숫점이나 e/E를 포함하는 수)를 저장하는 자료형으로서 float와 double 형이 있다. (이것은 C/C++과 동일하다.) 숫자 상수 끝에 f/F 접미어가 붙으면 float형으로 저장된다.

  컴퓨터에서는 모든 문자에 번호를 할당하고 문자를 정수로 바꿔서 저장한다. 어떤 문자에 어떤 번호를 할당하는 가는 여러 방법이 있으며 자바는 유니코드(unicode)라는 세계 표준 규격을 따른다. 유니코드는 국제적으로 사용되는 모든 문자를 0~65,535 범위(2 바이트)의 정수에 할당한 것이라고 이해하면 된다. 자바의 char형은 유니코드 한 문자를 표현할 수 있는 자료형으로서 2 byte 크기이다. 문자상수는 작은 따옴표를 사용하여 표시한다. 예를 들면 ‘a’, ‘가’, ‘3’ 등이다. (C/C++에서는 char형이 1byte이다. 혼동하면 안된다.)

  논리형은 true(참)과 false(거짓) 단 두 개의 값만을 가지는 자료형이다. 조건 검사에서 사용되는 논리식의 결과값을 저장하는 용도로 사용된다.




##3.삼항연산자의 형식및 간단한 예제 만들기

-  삼항연산자의 형식은 조건식 ? 피연산자1 : 피연산자2 
	- 조건식의 결과가 true면 결과는 피연산자 1, false면 피연산자2
	
	` int b1 = (5>4) ? 50 : 40;
        //조건식이 true이므로 b1은 50이 된다.`
        
        삼항연산자를 사용하여 코드의 라인이 줄어들었다고 컴파일 속도가 빨라지는 것은 아니다.
        삼항연산자를 중복해서 처리할 경우. 가독성이 떨어질 수 있으므로 중복처리는 피하는것이 좋다.

##4. 제어문의 종류및 형식을 설명하고 제어문당 간단한 예제 하나씩 만들기

#### 1. 제어문의 종류
* 조건문(decision-making statements): if문, switch문
* 반복문(looping statements): for문, while문
* 분기문(branching statements): break, continue, return

#### 2. 형식




##5. 배열의 개요및 배열의 생성,초기값을 부여하는 방법

#### 1. 배열 개요
- 배열이란 동일한 자료형(Data Type)의 데이터를 연속된 공간에 저장하기 위한 자료구조이다. 즉, 연관된 데이터를 그룹화하여 묶어준다고 생각하면 된다.  배열의 장점은 연관된 데이터를 저장하기 위한 변수의 선언을 줄여주며, 반복문 등을 이용하여 계산과 같은 과정을 쉽게 처리할 수 있다.

#### 2. 배열의 생성

    //int 타입 배열 선언
    int[] i_array;
    int i_array[]; 
	
    //배열 생성후 초기화하면 배열의 주소가 할당된다.
    int[] i_array = new int[8]; //초기값 0
    String[] s_array = new String[8]; //초기값 ""
		
    //배열 선언만 해놓고 나중에 초기화를 시킬수도 있다.
    int[] i_array;
    i_array = new array[8];

#### 3. 배열 초기화

    //배열에 특정값 대입하며 선언
    int[] i_array = {1,2,3,4,5};
    String[] s_array = {"a","b","c","d"};
		 
	//배열의 주소를 모두 같은값으로 초기화
	Arrays.fill(i_array,1);//i_array의 모든 index값을 1로 초기화
		
	//for문을 통해 값을 대입
	for(int i=0;i<i_array.length;i++) {
	    i_array[i]=i;
	}
	
	//foreach문을 통한 배열출력
	for(int i:i_array) {
	    System.out.print(i);
	}	


##6. 생성자,디폴트생성자 개요
> new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체 초기화를 담당. 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성시에 실행되어야할 작업을 위해 사용됨

-  생성자의 특징
	- 생성자는 리턴 타입이 없다
	-  생성자를 프로그래머가 만들지 않으면 매개변수가 없는 생성자가 컴파일할 때 자동으로 만들어진다.
	- 매개변수가 없는 생성자를 기본생성자라고 한다.
	- 생성자를 하나라도 프로그래머가 만들었다면 기본생성자는 자동으로 만들어지지 않는다.  

`ClassName c = new ClassName();`

연산자 new에 의해 메모리의 heap 영역에  ClassName의 인스턴스가 생성 ->  생성자 ClassName()이 호출되어 수행 -> 연산자 new의 결과로 생성된 ClassName 인스턴스의 주소가 반환되어 참조변수 c에 저장된다.



- 디폴트 생성자
모든 클래스는 생성자가 반드시 하나이상 있어야 하고, 클래스 내부에 생성자 선언을 하지 않았다면 컴파일러는 기본 생성자를 바이트코드에 추가시킨다.  `ClassName(){}` 컴파일러가 추가하는 기본 생성자는 매개변수가 없는 간단한 형태이다. 단, 컴파일러가 자동적으로 추가해주는 경우는 클래스에 정의된 생성자가 하나도 없을 때이다. 생성자가 하나라도 있다면 컴파일러는 기본 생성자를 추가하지 않는다.

		
	
##7. 메소드 오버로딩이란

- 메소드 오버로딩이란 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 갯수, 또는 타입이 다르다면, 같은 이름을 사용해서 메소드를 재정의 할 수 있는데 이를 메소드 오버로딩이라고 한다. 즉 클래스 내에서 같은 이름의 메소드를 여러개 선언할 수 있는데, 이유는 매개 값을 여러가지로 받아서 처리할 수 있게 하기 위함이다.

- 오버로딩의 조건
	- 메소드의 이름이 같아야한다
	-  매개변수의  갯수 또는 타입이 달라야한다.
	-  매개변수는 같고 리턴 타입이 다른 경우는 성립되지 않는다.
	-  오버로딩된 메소드들은 매개변수에 의해서만 구분이 가능하다.  

##8. private, protected, public 이란?
#### 접근 제어자
객체 지향에서 정보 은닉(data hiding)이란 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념이다.
그렇게 함으로써 사용자는 언제나 최소한의 정보만으로 프로그램을 손쉽게 사용할 수 있게 된다.
자바에서는 이러한 정보 은닉을 위해 접근 제어자(access modifier)라는 기능을 제공하고 있다.
접근 제어자를 사용하면 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 구체화할 수 있다.
자바에서는 다음과 같은 네 가지의 접근 제어자를 제공한다.


#### 1. private
private 접근 제어자를 사용하여 선언된 클래스 멤버는 외부에 공개되지 않으며, 외부에서는 직접 접근할 수 없다.
즉, 자바 프로그램은 private 멤버에 직접 접근할 수 없으며, 해당 객체의 public 메소드를 통해서만 접근할 수 있다.
따라서 private 멤버는 public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는 데 사용된다.

#### 2. public 
public 접근 제어자를 사용하여 선언된 클래스 멤버는 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다.
자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다.
따라서 public 메소드는 private 멤버와 프로그램 사이의 인터페이스(interface) 역할을 수행한다고 할 수 있다.

#### 3. default
자바에서는 클래스 및 클래스 멤버의 접근 제어의 기본값으로 default 접근 제어를 별도로 명시하고 있다.
이러한 default를 위한 접근 제어자는 따로 존재하지 않으며, 접근 제어자가 지정되지 않으면 자동적으로 default 접근 제어를 가지게 된다.
default 접근 제어를 가지는 멤버는 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근할 수 있다.


#### 4. protected
자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스를 구축한다.
여기에 부모 클래스(parent class)와 관련된 접근 제어자가 하나 더 존재한다.
protected 멤버는 부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급된다.
클래스의 protected 멤버에 접근할 수 있는 영역은 다음과 같다.

1. 이 멤버를 선언한 클래스의 멤버

2. 이 멤버를 선언한 클래스가 속한 패키지의 멤버

3. 이 멤버를 선언한 클래스를 상속받은 자식 클래스(child class)의 멤버
 


##9. import문의 형식

#### package
자바에서 패키지(package)란 클래스와 인터페이스의 집합을 의미한다.
이렇게 서로 관련이 있는 클래스나 인터페이스를 함께 묶음으로써 파일을 효율적으로 관리할 수 있게 된다.
또한, 협업 시 서로 작업한 클래스 사이에서 발생할 수 있는 이름 충돌 문제까지도 패키지를 이용하면 피할 수 있다.
자바에서 패키지는 물리적으로 하나의 디렉터리를 의미한다.
따라서 하나의 패키지에 속한 클래스나 인터페이스 파일은 모두 해당 패키지 이름의 디렉터리에 포함되어 있다.
이러한 패키지는 다른 패키지를 포함할 수 있으며, 이때 디렉터리의 계층 구조는 점(.)으로 구분된다.

#### import 
위와 같이 선언한 패키지에 속한 클래스를 다른 파일에서 사용하기 위해서는 클래스 이름 앞에 패키지의 경로까지 포함한 풀 네임을 명시해 사용해야 한다.
하지만 클래스를 사용할 때마다 매번 이렇게 긴 이름을 사용하는 것은 비효율적이므로, 자바에서는 import 키워드를 별도로 제공하고 있다.
import 문은 자바 컴파일러에 코드에서 사용할 클래스의 패키지에 대한 정보를 미리 제공하는 역할을 한다.
따라서 import 문을 사용하면 다른 패키지에 속한 클래스를 패키지 이름을 제외한 클래스 이름만으로 사용할 수 있게 된다.
자바에서 import 문은 다음과 같이 선언할 수 있다.

    1. import 패키지이름.클래스이름;

    2. import 패키지이름.*;

패키지 이름에는 패키지의 경로까지 포함한 풀 네임을 명시해야 한다.
첫 번째 방법은 해당 패키지의 특정 클래스만을 사용하고자 할 때 사용한다.
두 번째 방법은 해당 패키지의 모든 클래스를 클래스 이름만으로 사용하고 싶을 때 사용한다.


##10. this, super ?

super 키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 참조 변수이다.
인스턴스 변수의 이름과 지역 변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 사용하여 구분할 수 있다.
이와 마찬가지로 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 사용하여 구별할 수 있다.
이렇게 자바에서는 super 참조 변수를 사용하여 부모 클래스의 멤버에 접근할 수 있다.
this와 마찬가지로 super 참조 변수를 사용할 수 있는 대상도 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없다.



##11. final,static

* final 변수란?

변수를 상수화 시킨다. 즉 한번 값이 결정된 변수의 값은 변경이 불가능하다.

* final 클래스란?

클래스를 final로 선언한다면, 이 클래스를 상속하는 것을 허용하지 않겠다는 뜻이다. 대표적으로 String 클래스가 있다.  

* final 메소드란?

메소드를 final로 선언한다면, 이 메소드의 오버라이딩을 허용하지 않겠다는 뜻이다. 클래스는 상속이 가능하되 해당 메소드는 오버라이딩이 불가능하다.


* static 변수란?



static 으로 선언된 변수는 메모리 공간에 하나만 존재하며, 어디서나 접근이 가능한 변수이다.
어디서나 접근이 가능하려면 static 변수도 public으로 선언되어야 한다.



- 클래스 내부에서는 얼마든지 직접 접근이 가능하다.
- 클래스 외부에서 인스턴스의 이름이나 클래스의 이름을 통해 접근하는 것도 가능하다. (defalut 변수 일땐 동일한 패키지로 묶였을 경우)



* static 변수의 초기화 시점


static 변수는 인스턴스가 생성되기 이전에 별도의 메모리 공간에 할당되어 초기화까지 완료된다.
초기화되는 시점은 JVM(Java Virtual Machin) 에 의해서 클래스가 메모리 공간에 올라가는 순간이다.



* static 변수 사용 이유

인스턴스 간에 데이터 공유가 필요한 상황에서 static 변수를 선언한다.



* static final 선언


클래스 내부 또는 외부에서 참조의 용도로만 선언된 변수는 static final로 선언한다.
ex ) static final double PI = 3.14; 



* static 메소드란?

인스턴스를 생성하지 않아도 static 메소드를 호출할 수 있다.
사용 이유는 객체를 생성할 필요가 없는 메소드에 붙인다. 인스턴스 변수에 접근하지 않는다면 static 메소드로 정의해야 한다.



* public static void main 

main 메소드는 인스턴스의 생성과 관계없이 JVM에 의해 호출이 되므로 반드시 static 으로 선언해야 한다.



##12. 상속이란 ?


상속(inheritance)이란 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의하는 것을 의미한다.
이러한 상속은 캡슐화, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다.

상속을 이용하면 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다.

이때 기존에 정의되어 있던 클래스를 부모 클래스(parent class) 또는 상위 클래스(super class), 기초 클래스(base class)라고도한다.

그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스(child class) 또는 하위 클래스(sub class), 파생 클래스(derived class)라고도 한다.

#### 상속의 장점

1. 기존에 작성된 클래스를 재활용할 수 있습니다.

2. 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 됩니다.

3. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.

##13. Object 클래스 ?

java.lang.Object 클래스는 자바 API의 모든 클래스와 사용자가 정의한 모든 클래스의 최상위 클래스이다. 즉, 모든 자바 클래스들은 Object 클래스로부터 상속받는다.

사용자가 클래스를 정의할 때 클래스 선언부에 명시적으로 extends java.lang.Object를 지정하지 않아도 자동으로 상속받게 된다. 다시 말해 Object 클래스의 모든 메서드와 변수는 다른 모든 클래스에서도 사용 가능할 수 있다는 말이다.

##14. 메소드 오버라이딩 ?
 오버로딩(overloading)이란 서로 다른 시그니처를 갖는 여러 메소드를 하나의 이름으로 정의하는 것이었다.
오버라이딩(overriding)이란 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것이라고 할 수 있다.

자바에서 자식 클래스는 부모 클래스의 private 멤버를 제외한 모든 메소드를 상속받는다.

이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있다.

즉, 메소드 오버라이딩이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미한다.

#### 오버라이딩의 조건
자바에서 메소드를 오버라이딩하기 위한 조건은 다음과 같다.

 

1. 오버라이딩이란 메소드의 동작만을 재정의하는 것이므로, 메소드의 선언부는 기존 메소드와 완전히 같아한다. 하지만 메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환할 수 있는 타입이라면 변경할 수 있다.

2. 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없다

3. 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없다.

##15. String에 대하여 간단히 설명하고 중요메소드 10개만 설명 또는 사용법?
자바의 String은 불변하는 Unicode character들을 가지고 있다. C/C++에서는 문자열이 단순히 char의 배열인데 반해, 자바는 java.lang안에 있는 String 클래스의 객체를 의미한다. 일반 클래스와는 달리 자바의 String 클래스는 특별하다.

String은 "Hello, world!"와 같은 쌍따옴표로 감싸진 문자열 리터럴과 관련있다. 사용자는 생성자를 사용하는 대신 단순히 위와 같은 문자열 리터럴을 직접 String 변수에 대입할 수 있다.

[String class method](http://tcpschool.com/java/java_api_string)

##16. StringBuffer에 대하여 간단히 설명

String 클래스의 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없다.
하지만 StringBuffer 클래스의 인스턴스는 그 값을 변경할 수도 있고, 추가할 수도 있다.

이를 위해 StringBuffer 클래스는 내부적으로 버퍼(buffer)라고 하는 독립적인 공간을 가진다.
버퍼 크기의 기본값은 16개의 문자를 저장할 수 있는 크기이며, 생성자를 통해 그 크기를 별도로 설정할 수도 있다.
하지만 인스턴스 생성 시 사용자가 설정한 크기보다 언제나 16개의 문자를 더 저장할 수 있도록 여유 있는 크기로 생성된다.

덧셈(+) 연산자를 이용해 String 인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String 인스턴스를 생성한다.
따라서 문자열을 많이 결합하면 결합할수록 공간의 낭비뿐만 아니라 속도 또한 매우 느려지게 된다.

하지만 StringBuffer 인스턴스를 사용하면 문자열을 바로 추가할 수 있으므로, 공간의 낭비도 없으며 속도도 매우 빨라진다.
이러한 StringBuffer 클래스는 java.lang 패키지에 포함되어 제공된다.

##17. Calendar 클래스에 대한 간단한 설명(객체생성방법, 주요메소드등)

[Calendar Class 소개](http://tcpschool.com/java/java_api_calendar)

##18. 추상 클래스 ?


추상 클래스란 구체적이지 않은 클래스를 의미한다. 독수리, 타조는 구체적인 새를 지칭하는데 새, 포유류 같은 것은 구체적이지 않다.
이런 것을 구현한 클래스를 추상 클래스라고 한다.

* 추상 클래스 정의하기
	* 추상 클래스는 클래스 앞에 abstract 키워드를 이용해서 정의한다.
	* 추상 클래스는 미완성의 추상 메소드를 포함할 수 있다.
		* 추상 메소드란, 내용이 없는 메소드 이다. 즉 구현이 되지 않은 메소드이다.
		* 추상 메소드는 리턴 타입 앞에 abstract라는 키워드를 붙여야 한다.
	* 추상 클래스는 인스턴스를 생성할 수 없다.
